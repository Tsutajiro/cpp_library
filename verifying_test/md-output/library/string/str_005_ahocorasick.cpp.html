<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script type="text/javascript" src="../../assets/js/balloons.js"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: ../../string/str_005_ahocorasick.cpp</h1>
<ul>
<li>category: ../../string</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">// Aho-Corasick 法
// 入力文字列に対してマッチするパターンを検索
// N := 入力文字列の長さ、M := パターンの文字列の長さの合計とするとき、
// 計算量は O(N + M)
// Verified: JOI 2010 春合宿 Day2: DNA の合成

struct Elem {
    int wordidx, lidx, ridx;
};

const int SIZE = 256;
struct PMA {
    PMA* node[SIZE + 1];
    vector&lt;int&gt; matched;
    PMA() { memset(node, 0, sizeof(node)); }

    vector&lt;int&gt; unite(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) {
        vector&lt;int&gt; res;
        set_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res));
        return res;
    }

    void build(vector&lt;string&gt; pattern) {
        PMA* root = this;
        root -&gt; node[SIZE] = root;
        for(size_t i=0; i&lt;pattern.size(); i++) {
            // 入力文字を絞るときはここも変えよう
            PMA* now = root;
            for(size_t j=0; j&lt;pattern[i].length(); j++) {
                if(!now -&gt; node[ (int)pattern[i][j] ]) {
                    now -&gt; node[ (int)pattern[i][j] ] = new PMA;
                }
                now = now -&gt; node[ (int)pattern[i][j] ];
            }
            now -&gt; matched.push_back(i);
        }

        queue&lt;PMA*&gt; que;
        for(int i=0; i&lt;SIZE; i++) {
            if(!root -&gt; node[i]) root -&gt; node[i] = root;
            else {
                root -&gt; node[i] -&gt; node[SIZE] = root;
                que.push(root -&gt; node[i]);
            }
        }

        while(!que.empty()) {
            PMA* now = que.front(); que.pop();
            for(int i=0; i&lt;SIZE; i++) {
                if(now -&gt; node[i]) {
                    PMA *next = now -&gt; node[SIZE];
                    while(!next -&gt; node[i]) next = next -&gt; node[SIZE];
                    now -&gt; node[i] -&gt; node[SIZE] = next -&gt; node[i];
                    now -&gt; node[i] -&gt; matched = unite(now -&gt; node[i] -&gt; matched, next -&gt; node[i] -&gt; matched);
                    que.push(now -&gt; node[i]);
                }
            }
        }
    }

    // 検索対象の文字列から、どのパターン文字列がどのインデックスで現れたか (半開)
    vector&lt;Elem&gt; match(const string s, vector&lt;string&gt; pattern) {
        vector&lt;Elem&gt; res;
        PMA* pma = this;
        for(size_t i=0; i&lt;s.length(); i++) {
            // 入力文字を絞るときはここも変えよう
            int c = s[i];
            while(!pma -&gt; node[c]) pma = pma -&gt; node[SIZE];
            pma = pma -&gt; node[c];
            for(size_t j=0; j&lt;pma -&gt; matched.size(); j++) {
                int r = i+1, l = r - pattern[ pma -&gt; matched[j] ].length();
                res.push_back(Elem{pma -&gt; matched[j], l, r});
            }
        }
        return res;
    }
};
</code></pre>

<p><a href="../../index.html">Back to top page</a></p>