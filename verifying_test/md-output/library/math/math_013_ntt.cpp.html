<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script type="text/javascript" src="../../assets/js/balloons.js"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: ../../math/math_013_ntt.cpp</h1>
<ul>
<li>category: ../../math</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">// NTT (剰余環を用いた FFT)
// 任意 mod でやるなら、garner のアルゴリズム + ライブラリ下部が必須
// mod 998244353 なら NTT&lt;998244353, 5&gt; ntt; とかで十分です

template&lt;ll mod, ll primitive_root&gt;
struct NTT {
    int get_mod() { return mod; }

    vector&lt;ll&gt; dft(vector&lt;ll&gt; A, int N, int sgn = 1) {
        for(int i=0, j=1; j&lt;N-1; j++) {
            for(int k=N &gt;&gt; 1; k&gt;(i ^= k); k &gt;&gt;= 1);
            if(j &lt; i) swap(A[i], A[j]);
        }

        for(int m=2; m&lt;=N; m*=2) {
            ll zeta = mod_pow(primitive_root, (mod - 1) / m, mod);
            if(sgn &lt; 0) zeta = mod_pow(zeta, mod - 2, mod);

            for(int i=0; i&lt;N; i+=m) {
                ll zeta_pow = 1LL;
                for(int u=i, v=i+m/2; v&lt;i+m; u++, v++) {
                    ll vl = A[u], vr = zeta_pow * A[v] % mod;
                    A[u] = vl + vr;
                    A[v] = vl - vr + mod;
                    while(A[u] &gt;= mod) A[u] -= mod;
                    while(A[v] &gt;= mod) A[v] -= mod;
                    zeta_pow = zeta_pow * zeta % mod;
                }
            }
        }
        return A;
    }

    vector&lt;ll&gt; inv_dft(vector&lt;ll&gt; A, int N) {
        A = dft(A, N, -1);
        ll inv_N = mod_pow(N, mod-2, mod);
        for(int i=0; i&lt;N; i++) {
            (A[i] *= inv_N) %= mod;
        }
        return A;
    }

    vector&lt;ll&gt; multiply(vector&lt;ll&gt; A, vector&lt;ll&gt; B) {
        int sz = A.size() + B.size() + 1;
        int N = 1; while(N &lt; sz) N *= 2;

        A.resize(N), B.resize(N);
        A = dft(A, N), B = dft(B, N);

        vector&lt;ll&gt; F(N);
        for(int i=0; i&lt;N; i++) {
            F[i] = (A[i] * B[i]) % mod;
        }
        return inv_dft(F, N);
    }
};

// 以下、任意 mod 用
using NTT_1 = NTT&lt; 167772161, 3&gt;;
using NTT_2 = NTT&lt; 469762049, 3&gt;;
using NTT_3 = NTT&lt;1224736769, 3&gt;;

vector&lt;ll&gt; convolution_using_ntt(vector&lt;ll&gt; A, vector&lt;ll&gt; B, ll mod) {
    for(auto &amp;x : A) x %= mod;
    for(auto &amp;x : B) x %= mod;

    NTT_1 ntt_1; NTT_2 ntt_2; NTT_3 ntt_3;
    vector&lt; vector&lt;ll&gt; &gt; convo(3);
    convo[0] = ntt_1.multiply(A, B);
    convo[1] = ntt_2.multiply(A, B);
    convo[2] = ntt_3.multiply(A, B);

    int N = convo[0].size();
    vector&lt;ll&gt; ret(N), mods(3);
    mods[0] = ntt_1.get_mod();
    mods[1] = ntt_2.get_mod();
    mods[2] = ntt_3.get_mod();

    for(int i=0; i&lt;N; i++) {
        vector&lt;ll&gt; values(3);
        for(int k=0; k&lt;3; k++) {
            values[k] = convo[k][i];
        }
        ret[i] = garner(values, mods, mod);
    }
    return ret;
}

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>