<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script type="text/javascript" src="../../assets/js/balloons.js"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: ../../math/math_005_matrix_mod2.cpp</h1>
<ul>
<li>category: ../../math</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Required</h2>
<ul>
<li>:warning: <a href="verify/verify_math_005_matrix_mod2.cpp.html">../../math/verify/verify_math_005_matrix_mod2.cpp</a></li>
</ul>
<h2>Code</h2>
<pre><code class="cpp">// mod2 行列ライブラリ (bitset を使って高速化、横は SIZE 固定とする)
// TODO: 乗算の verify
struct BinaryMatrix {
    int H, W;
    static const int SIZE = 2010;
    vector&lt; bitset&lt;SIZE&gt; &gt; mat;
    BinaryMatrix(int H_, int W_) : H(H_), W(W_), mat(H_) {}

    // 乗算に使用 (これ微妙に転置じゃないけどなんていうんだ)
    BinaryMatrix T(const BinaryMatrix&amp; A) {
        int h = A.H, w = A.W;
        BinaryMatrix res(w, h);
        for(int i=0; i&lt;h; i++) {
            for(int j=0; j&lt;w; j++) {
                res[j][i] = A[i][j];
            }
        }
        return res;
    }

    BinaryMatrix&amp; operator*=(const BinaryMatrix&amp; rhs) {
        assert(W == rhs.H);
        BinaryMatrix res(H, rhs.W), trhs = T(rhs);
        for(int i=0; i&lt;H; i++) {
            for(int j=0; j&lt;rhs.W; j++) {
                res[i][j] = (mat[i] &amp; trhs[j]).count() % 2;
            }
        }
        return (*this = res);
    }
    BinaryMatrix&amp; operator+=(const BinaryMatrix &amp;rhs) {
        assert(H == rhs.H and W == rhs.W);
        for(int i=0; i&lt;H; i++) mat[i] ^= rhs[i];
        return *this;
    }
    BinaryMatrix&amp; operator-=(const BinaryMatrix &amp;rhs) {
        return (*this += rhs);
    }

    BinaryMatrix operator*(const BinaryMatrix &amp;rhs) {
        return (BinaryMatrix(*this) *= rhs);
    }
    BinaryMatrix operator+(const BinaryMatrix &amp;rhs) {
        return (BinaryMatrix(*this) += rhs);
    }
    BinaryMatrix operator-(const BinaryMatrix &amp;rhs) {
        return (BinaryMatrix(*this) -= rhs);
    }

    bool operator==(const BinaryMatrix &amp;rhs) const {
        if(H != rhs.H or W != rhs.W) return false;
        for(int i=0; i&lt;H; i++) if(mat[i] != rhs[i]) return false;
        return true;
    }
    bool operator!=(const BinaryMatrix &amp;rhs) const {
        return !(*this == rhs);
    }

    const bitset&lt;SIZE&gt;&amp; operator[](int k) const { return mat[k]; }
    bitset&lt;SIZE&gt;&amp; operator[](int k) { return mat[k]; }
};

BinaryMatrix eigen(size_t N) {
    BinaryMatrix res(N, N);
    for(size_t i=0; i&lt;N; i++) res[i][i] = 1;
    return res;
}

BinaryMatrix pow(BinaryMatrix mat, long long int k) {
    BinaryMatrix res = eigen(mat.H);
    for(; k&gt;0; k&gt;&gt;=1) {
        if(k &amp; 1) res *= mat;
        mat *= mat;
    }
    return res;
}

int gaussianEliminationBinary(BinaryMatrix &amp;mat, bool ext=false) {
    int N = mat.H, M = mat.W, rank = 0;
    for(int j=0; j+ext&lt;M; j++) {
        int piv = -1;
        for(int i=rank; i&lt;N; i++) {
            if(mat[i][j] != 0) piv = i, i = N;
        }
        if(piv &lt; 0) continue;
        swap(mat[rank], mat[piv]);
        for(int i=0; i&lt;N; i++) {
            if(i == rank or mat[i][j] == 0) continue;
            mat[i] ^= mat[rank];
        }
        rank++;
    }
    return rank;
}

vector&lt;int&gt; linearEquationBinary(BinaryMatrix A, vector&lt;int&gt; b) {
    int N = A.H, M = A.W;
    BinaryMatrix mat(N, M+1);
    for(int i=0; i&lt;N; i++) {
        for(int j=0; j&lt;=M; j++) {
            mat[i][j] = (j &lt; M ? A[i][j] : b[i]);
        }
    }

    int rank = gaussianEliminationBinary(mat, true);
    vector&lt;int&gt; res(N);
    for(int i=0; i&lt;N; i++) {
        res[i] = mat[i][M];
        if(i &gt;= rank and mat[i][M] != 0) return {};
    }
    return res;
}

int detBinary(BinaryMatrix A) {
    int N = A.H;
    for(int j=0; j&lt;N; j++) {
        int piv = -1;
        for(int i=j; i&lt;N; i++) {
            if(A[i][j] != 0) piv = i, i = N;
        }
        if(piv &lt; 0) return 0;
        swap(A[piv], A[j]);
        for(int i=j+1; i&lt;N; i++) {
            if(A[i][j]) A[i] ^= A[j];
        }
    }
    int res = 1;
    for(int i=0; i&lt;N; i++) res *= A[i][i];
    return res;
}

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>