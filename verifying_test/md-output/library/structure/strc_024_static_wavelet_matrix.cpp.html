<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script type="text/javascript" src="../../assets/js/balloons.js"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: ../../structure/strc_024_static_wavelet_matrix.cpp</h1>
<ul>
<li>category: ../../structure</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h3>静的ウェーブレット行列 (Wavelet Matrix)</h3>
<p>簡潔ビットベクトルにより非負整数列に対する各種クエリを高速に処理可能</p>
<h4>Usage</h4>
<ul>
<li>注釈が特にないものは 0-indexed</li>
<li>変数について</li>
<li>$N$: 数列の長さ</li>
<li>$\sigma$: 値域</li>
<li><strong>Usage、ソースコードの中身は間違っているかもしれません: 指摘があれば教えてください</strong></li>
</ul>
<table>
<thead>
<tr>
<th>メソッド</th>
<th>説明</th>
<th>計算量</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WaveletMatrix(vec)</code></td>
<td>vector から Wavelet 行列を構築</td>
<td>$O(N \log \sigma)$</td>
</tr>
<tr>
<td><code>at(k)</code></td>
<td>列のインデックス $k$ 番目 (0-indexed) にアクセス</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>operator[](k)</code></td>
<td>列のインデックス $k$ 番目 (0-indexed) にアクセス</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>rank_tuple(l, r, x)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内に ($x$ 未満、$x$ と等しい、$x$ を超える) 要素がそれぞれいくつ存在するか答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>rank_tuple(x)</code></td>
<td>数列全体で ($x$ 未満、$x$ と等しい、$x$ を超える) 要素がそれぞれいくつ存在するか答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>quantile(l, r, mi, ma, k)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にあって値が $\left[ \mathrm{mi}, \mathrm{ma} \right]$ に収まる要素のうち、$k$ 番目 (1-indexed) に小さいものを答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>quantile(l, r, k)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にある要素のうち、$k$ 番目 (1-indexed) に小さいものを答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>quantile(k)</code></td>
<td>数列全体で $k$ 番目 (1-indexed) に小さいものを答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>freq_less(l, r, m)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にあって値が $m$ 未満の要素がいくつ存在するか答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>freq_less(m)</code></td>
<td>数列全体に値が $m$ 未満の要素がいくつ存在するか答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>freq_greater(l, r, m)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にあって値が $m$ を超える要素がいくつ存在するか答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>freq_greater(m)</code></td>
<td>数列全体に値が $m$ を超える要素がいくつ存在するか答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>freq(l, r, mi, ma)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にあって値が $\left[ \mathrm{mi}, \mathrm{ma} \right]$ に収まる要素がいくつ存在するか答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>freq(l, r, x)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にあって値が $x$ と等しい要素がいくつ存在するか答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>freq(mi, ma)</code></td>
<td>数列全体に値が $\left[ \mathrm{mi}, \mathrm{ma} \right]$ に収まる要素がいくつ存在するか答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>min_value(l, r, mi, ma)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にあって値が $\left[ \mathrm{mi}, \mathrm{ma} \right]$ に収まる要素のうち最小値を答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>min_value(l, r)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にある要素のうち最小値を答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>min_value()</code></td>
<td>数列全体の要素の最小値を答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>max_value(l, r, mi, ma)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にあって値が $\left[ \mathrm{mi}, \mathrm{ma} \right]$ に収まる要素のうち最大値を答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>max_value(l, r)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にある要素のうち最大値を答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>max_value()</code></td>
<td>数列全体の要素の最大値を答える</td>
<td>$O(\log \sigma)$</td>
</tr>
<tr>
<td><code>select(l, r, k, x)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にある $x$ と等しい要素のうち $k$ 番目 (1-indexed) にある値のインデックスを答える</td>
<td>$O(\log \sigma \log N)$</td>
</tr>
<tr>
<td><code>select(k, x)</code></td>
<td>数列全体で $x$ と等しい要素のうち $k$ 番目 (1-indexed) にある値のインデックスを答える</td>
<td>$O(\log \sigma \log N)$</td>
</tr>
<tr>
<td><code>next_val(l, r, x)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にあって値が $x$ を超える要素の中で最小のものを答える</td>
<td>$O(\log \sigma \log N)$</td>
</tr>
<tr>
<td><code>prev_val(l, r, x)</code></td>
<td>インデックス $\left[ l, r \right)$ の範囲内にあって値が $x$ 未満の要素の中で最小のものを答える</td>
<td>$O(\log \sigma \log N)$</td>
</tr>
</tbody>
</table>
<h2>Dependencies</h2>
<ul>
<li>:warning: <a href="strc_023_compact_bitvector.cpp.html">../../structure/strc_023_compact_bitvector.cpp</a></li>
</ul>
<h2>Required</h2>
<ul>
<li>:warning: <a href="verify/verify_strc_024_static_wavelet_matrix.cpp.html">../../structure/verify/verify_strc_024_static_wavelet_matrix.cpp</a></li>
</ul>
<h2>Verified</h2>
<ul>
<li>:warning: <a href="../../verify/verifying_test/AOJ/1549/static_wavelet_matrix.test.cpp.html">../../verifying_test/AOJ/1549/static_wavelet_matrix.test.cpp</a></li>
<li>:warning: <a href="../../verify/verifying_test/AOJ/2426/static_wavelet_matrix.test.cpp.html">../../verifying_test/AOJ/2426/static_wavelet_matrix.test.cpp</a></li>
<li>:warning: <a href="../../verify/verifying_test/AOJ/ALDS1_5_D/static_wavelet_matrix_less.test.cpp.html">../../verifying_test/AOJ/ALDS1_5_D/static_wavelet_matrix_less.test.cpp</a></li>
<li>:warning: <a href="../../verify/verifying_test/AOJ/ALDS1_5_D/static_wavelet_matrix_more.test.cpp.html">../../verifying_test/AOJ/ALDS1_5_D/static_wavelet_matrix_more.test.cpp</a></li>
<li>:warning: <a href="../../verify/verifying_test/AOJ/ALDS1_6_A/static_wavelet_matrix.test.cpp.html">../../verifying_test/AOJ/ALDS1_6_A/static_wavelet_matrix.test.cpp</a></li>
<li>:warning: <a href="../../verify/verifying_test/AOJ/DSL_3_D/static_wavelet_matrix.test.cpp.html">../../verifying_test/AOJ/DSL_3_D/static_wavelet_matrix.test.cpp</a></li>
<li>:warning: <a href="../../verify/verifying_test/AOJ/ITP1_6_A/static_wavelet_matrix.test.cpp.html">../../verifying_test/AOJ/ITP1_6_A/static_wavelet_matrix.test.cpp</a></li>
</ul>
<h2>Code</h2>
<pre><code class="cpp">#define DOCS &quot;./docs/strc_024_static_wavelet_matrix.md&quot;
#define REQUIRES &quot;./strc_023_compact_bitvector.cpp&quot;
#undef REQUIRES

// ウェーブレット行列 (Wavelet Matrix)
// w は ビット幅, 30 bit で表現できる整数なら 30
template &lt;uint64_t word_size = 30, typename value_type = int,
          uint64_t ln_big = 10, uint64_t ln_sml = 4&gt;
struct WaveletMatrix {
private:
    using BitVector = CompactBitVector&lt;value_type, ln_big, ln_sml&gt;;
    array&lt;BitVector, word_size&gt; vecs;

    // 要素数
    int n;
    // k ビット目を基準に安定ソート
    vector&lt;value_type&gt; sort_kth_bit(const vector&lt;value_type&gt;&amp; vec, int k) const;

    // [l, r) の範囲内にある x と等しい要素は最下段のどの範囲に相当？
    // select するときに利用
    pair&lt;int, int&gt; rank_range(int l, int r, value_type x) const;    

public:
    // クエリは特に注釈がない限り 0-indexed
    // 構築: O(N w)
    WaveletMatrix(vector&lt;value_type&gt; vec);

    // k 番目の値を復元: O(w)
    // &lt;verified&gt; ITP1_6_A (Reversing Numbers)
    value_type at(int k) const;
    value_type operator[](int k) const;

    // [l, r) の範囲内に以下が何個存在するか: O(w)
    // ・x より小さい要素
    // ・x と等しい要素
    // ・x より大きい要素
    tuple&lt;int, int, int&gt; rank_tuple(int l, int r, value_type x) const;
    tuple&lt;int, int, int&gt; rank_tuple(value_type x) const;

    // [l, r) の範囲内で k 番目 (1-indexed) に小さい要素が何か: O(w)
    // &lt;verified&gt; AOJ ALDS1_6_A (Count Sort)
    value_type quantile(int l, int r, value_type mi, value_type ma, int k) const;
    value_type quantile(int l, int r, int k) const;
    value_type quantile(int k) const;

    // [l, r) の範囲内の m 未満 / m を超える 要素はいくつか: O(w)
    // &lt;verified&gt; AOJ ALDS1_5_D (The Number of Inversions)
    int freq_less(int l, int r, value_type m) const;
    int freq_less(value_type m) const;
    int freq_greater(int l, int r, value_type m) const;
    int freq_greater(value_type m) const;

    // [l, r) の範囲内に x \in [mi, ma] を満たす x がいくつ出てきたか: O(w)
    // [mi, ma] は閉区間！！
    // &lt;verified&gt; AOJ 1549 (Hard Beans)
    // &lt;verified&gt; AOJ 2426 (Treasure Hunt)
    int freq(int l, int r, value_type mi, value_type ma) const;
    int freq(int l, int r, value_type x) const;
    int freq(value_type mi, value_type ma) const;

    // [l, r) の範囲内にある要素の最小値 (quantile 再利用): O(w)
    // &lt;verified&gt; AOJ DSL_3_D (Sliding Minimum Elements)
    value_type min_value(int l, int r, value_type mi, value_type ma) const;
    value_type min_value(int l, int r) const;
    value_type min_value() const;

    // [l, r) の範囲内にある要素の最大値 (quantile 再利用): O(w)
    value_type max_value(int l, int r, value_type mi, value_type ma) const;
    value_type max_value(int l, int r) const;
    value_type max_value() const;

    // [l, r) の範囲内にある k 番目 (1-indexed) の x の位置: O(w log N)
    int select(int l, int r, int k, value_type x) const;
    int select(int k, value_type x) const;

    // k 番目の要素と値が等しいもので、k 番目の直後 / 直前の要素 idx: O(w log N)
    int next_idx(int k) const;
    int prev_idx(int k) const;

    // [l, r) の範囲内にある、x 未満 / x を超える要素のうち 最大 / 最小 であるもの: O(w)
    // &lt;verified&gt; AOJ 1549 (Hard Beans)
    value_type next_val(int l, int r, value_type x) const;
    value_type prev_val(int l, int r, value_type x) const;
};

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
vector&lt;value_type&gt; WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::sort_kth_bit(const vector&lt;value_type&gt;&amp; vec, int k) const {
    vector&lt;value_type&gt; v0, v1;
    v0.reserve(vec.size()), v1.reserve(vec.size());
    for(size_t i=0; i&lt;vec.size(); i++) {
        ((vec[i] &gt;&gt; k &amp; 1) ? v1 : v0).emplace_back(vec[i]);
    }
    v0.insert(v0.end(), v1.begin(), v1.end());
    return v0;
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
pair&lt;int, int&gt; WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::rank_range(int l, int r, value_type x) const {
    for(size_t i=0; i&lt;word_size; i++) {
        int all1 = vecs[i].rank(n-1), all0 = n - all1;
        int cnt1 = vecs[i].rank(r-1) - vecs[i].rank(l-1), cnt0 = r - l - cnt1;
        if(x &gt;&gt; (word_size - i - 1) &amp; 1) {
            l = all0 + vecs[i].rank(l-1), r = l + cnt1;
        }
        else {
            l = l - vecs[i].rank(l-1), r = l + cnt0;
        }
    }
    return make_pair(l, r);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::WaveletMatrix(vector&lt;value_type&gt; vec) : n(vec.size()) {
    vecs[0] = BitVector(vec, word_size - 1);
    for(size_t i=1; i&lt;word_size; i++) {
        vec = sort_kth_bit(vec, word_size - i);
        vecs[i] = BitVector(vec, word_size - i - 1);
    }
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::at(int k) const {
    int b = k; value_type res = 0;
    for(size_t i=0; i&lt;word_size; i++) {
        int all1 = vecs[i].rank(n-1), all0 = n - all1;
        int cnt1 = vecs[i].rank(b), cnt0 = b + 1 - cnt1;
        if(vecs[i][b] == 1) {
            res |= (1ULL &lt;&lt; (word_size - 1 - i));
            b = all0 + cnt1 - 1;
        }
        else {
            b = cnt0 - 1;
        }
    }
    return res;
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::operator[](int k) const {
    return at(k);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
tuple&lt;int, int, int&gt; WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::rank_tuple(int l, int r, value_type x) const {
    int small = 0, equal = 0, big = 0;
    for(size_t i=0; i&lt;word_size; i++) {
        int all1 = vecs[i].rank(n-1), all0 = n - all1;
        int cnt1 = vecs[i].rank(r-1) - vecs[i].rank(l-1), cnt0 = r - l - cnt1;
        if(x &gt;&gt; (word_size - i - 1) &amp; 1) {
            small += cnt0;
            l = all0 + vecs[i].rank(l-1), r = l + cnt1;
        }
        else {
            big += cnt1;
            l = l - vecs[i].rank(l-1), r = l + cnt0;
        }
    }
    equal = r - l;
    return make_tuple(small, equal, big);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
tuple&lt;int, int, int&gt; WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::rank_tuple(value_type x) const {
    return rank_tuple(0, n, x);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::quantile(int l, int r, value_type mi, value_type ma, int k) const {
    int cnt_less = freq_less(l, r, mi), cnt_greater = freq_greater(l, r, ma);
    if(r - l - cnt_less - cnt_greater &lt; k) return -1;
    return quantile(l, r, k + cnt_less);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::quantile(int l, int r, int k) const {
    if(r - l &lt; k) return -1;
    value_type res = 0;
    for(size_t i=0; i&lt;word_size; i++) {
        int all1 = vecs[i].rank(n-1), all0 = n - all1;
        int cnt1 = vecs[i].rank(r-1) - vecs[i].rank(l-1), cnt0 = r - l - cnt1;
        if(cnt0 &gt;= k) {
            l = l - vecs[i].rank(l-1), r = l + cnt0;
        }
        else {
            k -= cnt0;
            res |= 1ULL &lt;&lt; (word_size - 1 - i);
            l = all0 + vecs[i].rank(l-1), r = l + cnt1;
        }
    }
    return res;
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::quantile(int k) const {
    return quantile(0, n, k);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
int WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::freq_less(int l, int r, value_type m) const {
    int res = 0;
    for(size_t i=0; i&lt;word_size; i++) {
        int all1 = vecs[i].rank(n-1), all0 = n - all1;
        int cnt1 = vecs[i].rank(r-1) - vecs[i].rank(l-1), cnt0 = r - l - cnt1;
        if(m &gt;&gt; (word_size - 1 - i) &amp; 1) {
            res += cnt0;
            l = all0 + vecs[i].rank(l-1), r = l + cnt1;
        }
        else {
            l = l - vecs[i].rank(l-1), r = l + cnt0;
        }
    }
    return res;
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
int WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::freq_less(value_type m) const {
    return freq_less(0, n, m);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
int WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::freq_greater(int l, int r, value_type m) const {
    int res = 0;
    for(size_t i=0; i&lt;word_size; i++) {
        int all1 = vecs[i].rank(n-1), all0 = n - all1;
        int cnt1 = vecs[i].rank(r-1) - vecs[i].rank(l-1), cnt0 = r - l - cnt1;
        if(m &gt;&gt; (word_size - 1 - i) &amp; 1) {
            l = all0 + vecs[i].rank(l-1), r = l + cnt1;
        }
        else {
            res += cnt1;
            l = l - vecs[i].rank(l-1), r = l + cnt0;
        }
    }
    return res;
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
int WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::freq_greater(value_type m) const {
    return freq_greater(0, n, m);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
int WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::freq(int l, int r, value_type mi, value_type ma) const {
    return r - l - freq_less(l, r, mi) - freq_greater(l, r, ma);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
int WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::freq(int l, int r, value_type x) const {
    return freq(l, r, x, x);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
int WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::freq(value_type mi, value_type ma) const {
    return freq(0, n, mi, ma);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::min_value(int l, int r, value_type mi, value_type ma) const {
    return quantile(l, r, mi, ma, 1);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::min_value(int l, int r) const {
    return quantile(l, r, 1);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::min_value() const {
    return min_value(0, n);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::max_value(int l, int r, value_type mi, value_type ma) const {
    return quantile(l, r, mi, ma, freq(l, r, mi, ma));
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::max_value(int l, int r) const {
    return quantile(l, r, r - l);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::max_value() const {
    return max_value(0, n);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
int WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::select(int l, int r, int k, value_type x) const {
    if(k &lt;= 0) return -1;
    tie(l, r) = rank_range(l, r, x);
    if(r - l &lt; k) return -1;

    int pos = l + k - 1;
    for(size_t i=0; i&lt;word_size; i++) {
        int b = x &gt;&gt; i &amp; 1;
        int cnt1 = vecs[word_size - 1 - i].rank(n-1), cnt0 = n - cnt1;
        if(b == 0) {
            int m = pos;
            pos = vecs[word_size - 1 - i].select0(m, n);
        }
        else {
            int m = pos - cnt0;
            pos = vecs[word_size - 1 - i].select1(m, n);
        }
    }
    return pos;
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
int WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::select(int k, value_type x) const {
    return select(0, n, k, x);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
int WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::next_idx(int k) const {
    int m = freq(0, k+1, at(k));
    return select(m+1, at(k));
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
int WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::prev_idx(int k) const {
    int m = freq(0, k+1, at(k));
    return select(m-1, at(k));
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::next_val(int l, int r, value_type x) const {
    int k = r - l - freq_greater(l, r, x) + 1;
    return quantile(l, r, k);
}

template &lt;uint64_t word_size, typename value_type,
          uint64_t ln_big, uint64_t ln_sml&gt;
value_type WaveletMatrix&lt;word_size, value_type, ln_big, ln_sml&gt;::prev_val(int l, int r, value_type x) const {
    return quantile(l, r, freq_less(l, r, x));
}

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>