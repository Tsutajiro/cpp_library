<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script type="text/javascript" src="../../assets/js/balloons.js"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: ../../structure/strc_019_intervalset.cpp</h1>
<ul>
<li>category: ../../structure</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">// 区間を set で管理するやつ
// 閉区間 [l, r] を扱うことに注意
template &lt;typename numericType, numericType infty = numeric_limits&lt;numericType&gt;::max() &gt;
struct IntervalSet : set&lt; pair&lt;numericType, numericType&gt; &gt; {
    // x を含む閉区間 [l, r] を取得
    // イテレータを返す
    auto get(numericType x) {
        // x より始点が大きい区間の中で最小のもの
        auto itr = this-&gt;upper_bound(make_pair(x, infty));
        if(itr == this-&gt;begin() or (--itr)-&gt;second &lt; x) return this-&gt;end();
        return itr;
    }

    // [l, r] と overlap する区間の集合を取得
    // vector を返す
    vector&lt; pair&lt;numericType, numericType&gt; &gt; get(numericType l, numericType r) {
        auto itr = this-&gt;upper_bound(make_pair(l, l));
        if(itr != this-&gt;begin()) itr--;

        vector&lt; pair&lt;numericType, numericType&gt; &gt; res;
        for(; itr != this-&gt;end(); itr++) {
            numericType il, ir; tie(il, ir) = *itr;
            if(r &lt; il) break; // 対称区間に対して右に飛び出た
            // 対称区間に対して左に飛び出るか、含まれているかしかない
            if(ir &gt;= l) res.push_back(make_pair(il, ir));
        }
        return res;
    }

    void insert(numericType l, numericType r) {
        auto vec = this-&gt;get(l, r);
        numericType il = l, ir = r;
        for(auto e : vec) {
            this-&gt;erase(e);
            il = min(il, e.first);
            ir = max(ir, e.second);
        }
        this-&gt;emplace(il, ir);
    }

    void remove(numericType l, numericType r) {
        auto vec = this-&gt;get(l, r);
        for(auto e : vec) this-&gt;erase(e);
    }

    // p と q は同じ区間上にあるか？
    bool same(numericType p, numericType q) {
        auto itr = get(p);
        return itr != this-&gt;end() and itr-&gt;first &lt;= q and q &lt;= itr.second;
    }

    void dump() {
        for(auto e : *this) {
            numericType l, r; tie(l, r) = e;
            fprintf(stderr, &quot;# debug: [%g, %g]\n&quot;, l, r);
        }
    }
};

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>