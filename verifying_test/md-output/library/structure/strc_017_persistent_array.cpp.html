<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script type="text/javascript" src="../../assets/js/balloons.js"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: ../../structure/strc_017_persistent_array.cpp</h1>
<ul>
<li>category: ../../structure</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">// 永続配列 (2^{LOG} 分木による実装)
// パスコピーは mutable_get で行おう！値を持ってくるだけなら get を使おう

template &lt;typename Type, int LOG&gt;
struct PersistentArray {
    struct Node {
        Type data;
        Node* child[1 &lt;&lt; LOG] = {};
        Node() {}
        Node(const Type&amp; data_) : data(data_) {}
    };
    Node* root;

    PersistentArray() : root(nullptr) {}
    Type get(Node* t, int k) {
        if(k == 0) return t-&gt;data;
        return get(t-&gt;child[k &amp; ((1 &lt;&lt; LOG) - 1)], k &gt;&gt; LOG);
    }

    Type get(const int&amp; k) {
        return get(root, k);
    }

    pair&lt;Node*, Type*&gt; mutable_get(Node* t, int k) {
        t = t ? new Node(*t) : new Node();
        if(k == 0) return {t, &amp;t-&gt;data};
        auto p = mutable_get(t-&gt;child[k &amp; ((1 &lt;&lt; LOG) - 1)], k &gt;&gt; LOG);
        t-&gt;child[k &amp; ((1 &lt;&lt; LOG) - 1)] = p.first;
        return {t, p.second};
    }

    Type* mutable_get(const int&amp; k) {
        auto ret = mutable_get(root, k);
        root = ret.first;
        return ret.second;
    }

    Node* build(Node* t, const Type&amp; data, int k) {
        if(!t) t = new Node();
        if(k == 0) {
            t-&gt;data = data;
            return t;
        }
        auto p = build(t-&gt;child[k &amp; ((1 &lt;&lt; LOG) - 1)], data, k &gt;&gt; LOG);
        t-&gt;child[k &amp; ((1 &lt;&lt; LOG) - 1)] = p;
        return t;
    }

    void build(const vector&lt;Type&gt;&amp; vec) {
        root = nullptr;
        for(size_t i=0; i&lt;vec.size(); i++) {
            root = build(root, vec[i], i);
        }
    }
};
</code></pre>

<p><a href="../../index.html">Back to top page</a></p>