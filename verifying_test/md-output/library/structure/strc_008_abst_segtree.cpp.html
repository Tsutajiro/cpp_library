<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script type="text/javascript" src="../../assets/js/balloons.js"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: ../../structure/strc_008_abst_segtree.cpp</h1>
<ul>
<li>category: ../../structure</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Required</h2>
<ul>
<li>:warning: <a href="../graph/verify/verify_graph_020_HLDecomposition.cpp.html">../../graph/verify/verify_graph_020_HLDecomposition.cpp</a></li>
<li>:warning: <a href="../string/verify/verify_str_009_manacher.cpp.html">../../string/verify/verify_str_009_manacher.cpp</a></li>
<li>:warning: <a href="verify/verify_strc_008_abst_segtree.cpp.html">../../structure/verify/verify_strc_008_abst_segtree.cpp</a></li>
</ul>
<h2>Code</h2>
<pre><code class="cpp">// 抽象 SegmentTree (0-indexed・一点更新・区間取得)
template &lt;typename MonoidType&gt;
struct SegmentTree {
    using Function = function&lt; MonoidType(MonoidType, MonoidType) &gt;;

    // node, identity element
    int n;
    vector&lt;MonoidType&gt; node;
    MonoidType E0;

    // update / combine function
    Function upd_f, cmb_f;

    void build(int m, vector&lt;MonoidType&gt; v = vector&lt;MonoidType&gt;()) {
        if(v != vector&lt;MonoidType&gt;()) m = v.size();
        n = 1; while(n &lt; m) n *= 2;

        node = vector&lt;MonoidType&gt;(2*n-1, E0);
        if(v != vector&lt;MonoidType&gt;()) {
            for(int i=0; i&lt;m; i++) {
                node[n-1+i] = v[i];
            }
            for(int i=n-2; i&gt;=0; i--) {
                node[i] = cmb_f(node[2*i+1], node[2*i+2]);
            }
        }
    }

    // initialize
    SegmentTree() {}
    SegmentTree(int n_, MonoidType E0_,
                Function upd_f_, Function cmb_f_,
                vector&lt;MonoidType&gt; v = vector&lt;MonoidType&gt;()) :
        E0(E0_), upd_f(upd_f_), cmb_f(cmb_f_) {
        build(n_, v);
    }

    // update k-th element (applied value: x)
    void update(int k, MonoidType x) {
        k += n - 1;
        node[k] = upd_f(node[k], x);
        while(k &gt; 0) {
            k = (k - 1) / 2;
            node[k] = cmb_f(node[2*k+1], node[2*k+2]);
        }
    }

    // range query for [a, b)
    // 非再帰のアイデア: http://d.hatena.ne.jp/komiyam/20131202/1385992406
    MonoidType query(int a, int b) {
        MonoidType vl = E0, vr = E0;
        for(int l=a+n, r=b+n; l&lt;r; l&gt;&gt;=1, r&gt;&gt;=1) {
            if(l &amp; 1) vl = cmb_f(vl, node[(l++)-1]);
            if(r &amp; 1) vr = cmb_f(node[(--r)-1], vr);
        }
        return cmb_f(vl, vr);
    }
};

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>