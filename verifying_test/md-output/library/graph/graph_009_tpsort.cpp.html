<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script type="text/javascript" src="../../assets/js/balloons.js"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: ../../graph/graph_009_tpsort.cpp</h1>
<ul>
<li>category: ../../graph</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">// トポロジカルソート 各種

// 2016/12/27 追記: 有向グラフの閉路検査はトポロジカルソートで容易に行える。
// → 閉路があれば入次数 0 になりえない頂点が存在する
// → トポロジカルソートした結果の vector の size が頂点数と等しくなければ閉路が存在

// Kahnのトポロジカルソートアルゴリズム (Verified: AOJ GRL_4_B: Topological Sort)
template &lt;typename T&gt;
vector&lt;int&gt; tpsort_Kahn(const vector&lt; vector&lt; Edge&lt;T&gt; &gt; &gt; &amp;g) {
    const int V = g.size();
    vector&lt;int&gt; indeg(V, 0);
    stack&lt;int&gt; S;

    for(size_t i=0; i&lt;V; i++) {
        for(size_t j=0; j&lt;g[i].size(); j++) {
            indeg[ g[i][j].to ]++;
        }
    }
    for(int i=0; i&lt;V; i++) {
        if(indeg[i] == 0) S.push(i);
    }

    vector&lt;int&gt; ans;
    while(S.size() &gt; 0) {
        int u = S.top(); S.pop();
        ans.push_back(u);
        for(size_t i=0; i&lt;g[u].size(); i++) {
            indeg[ g[u][i].to ]--;
            if(indeg[ g[u][i].to ] ==  0)
                S.push( g[u][i].to );
        }
    }
    return ans;
}

// Tarjanのトポロジカルソートアルゴリズム (Verified: AOJ GRL_4_B: Topological Sort)
template &lt;typename T&gt;
void tpTarjanVisit(const vector&lt; vector&lt; Edge&lt;T&gt; &gt; &gt; &amp;g, int u, vector&lt;bool&gt; &amp;used, vector&lt;int&gt; &amp;ans) {
    if(used[u] == false) {
        used[u] = true;
        for(size_t i=0; i&lt;g[u].size(); i++) 
            tpTarjanVisit(g, g[u][i].to, used, ans);
        ans.push_back(u);
    }
}

template &lt;typename T&gt;
vector&lt;int&gt; tpsort_Tarjan(const vector&lt; vector&lt; Edge&lt;T&gt; &gt; &gt; &amp;g) {
    const int V = g.size();
    vector&lt;bool&gt; used(V, false);
    vector&lt;int&gt; ans;
    for(int i=0; i&lt;V; i++) tpTarjanVisit(g, i, used, ans);
    reverse(ans.begin(), ans.end());
    return ans;
}

// bit DP によるトポロジカルソートの組み合わせ列挙 (ABC041 D)

int const MAX_N = 16;
vector&lt;int&gt; p[MAX_N];
ll dp[1 &lt;&lt; MAX_N];
int N, M;

// 前から頂点のパターンを決定していき、組み合わせの数を返す
ll dfs(int x) {
    ll &amp;ret = dp[x];
    // すでに値が書き込んであればそれを返す
    if(ret &gt;= 0) return ret;
    // 最後までいったら1通りしかない
    if(x == (1 &lt;&lt; N) - 1) return ret = 1;

    ret = 0;
    for(int i=0; i&lt;N; i++) {
        // まだ使ってない頂点を使う
        if(((x &gt;&gt; i) &amp; 1) == 0) {
            bool ng = false;

            // j は p[i] の中の要素
            for(int j : p[i]) {
                // 頂点集合の中に行先がすでにあるということは、
                // トポロジカルソートの一番右になりえない → NG
                if(((x &gt;&gt; j) &amp; 1) == 0) {
                    ng = true;
                    break;
                }
            }
            if(ng) continue;

            // 頂点 i を使ったので、それを含めた集合で dfs する
            ret += dfs(x | (1 &lt;&lt; i));
        }
    }
    return ret;
}

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>