<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script type="text/javascript" src="../../assets/js/balloons.js"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: ../../graph/graph_013_rootedtreeiso.cpp</h1>
<ul>
<li>category: ../../graph</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">// 根付き木の同型性判定アルゴリズム O(|V|)
// ・葉の値を 1 とする
// ・親は子のハッシュの結果をソートして足しあわせたものをハッシュに入れた値である
// ・根のハッシュ値が一致していれば、木は同型である
// ・根なし木で同型性判定を行うには、木の中心を根にして同型性判定を行えば良い
//   -&gt; 同型な木であれば、中心を根として判定しても結果が同じなのは自明
//   -&gt; 木の中心は高々 2 個 (直径が奇数長なら 1 個、偶数長なら 2 個)
//   -&gt; ハッシュの計算を高々 2 * 2 = 4 回やるだけで済むため、十分高速である
// ・注意: 木の中心の個数が一致しなければ同型でないことは明らかなので、
//   ハッシュに突っ込む前に中心の個数を先にチェックすべき (かもしれない)

map&lt;string, ll&gt; HASHMAP;
ll cntPattern = 1; // you must write in main: cntPattern = 1;

template &lt;typename T&gt;
ll getHash(vector&lt; vector&lt; Edge&lt;T&gt; &gt; &gt; &amp;G, int point, int parent = -1) {
    // leaf
    if(G[point].size() == 1 &amp;&amp; parent != -1)
        return HASHMAP[&quot;0&quot;] = 1;

    vector&lt;string&gt; rec;
    for(size_t i=0; i&lt;G[point].size(); i++) {
        int to = G[point][i].to;
        if(to == parent) continue;
        ll temp = getHash(G, to, point);
        rec.push_back(to_string(temp));
    }
    sort(rec.begin(), rec.end());
    string pat = &quot;&quot;;
    for(size_t i=0; i&lt;rec.size(); i++) pat += rec[i];
    if(!HASHMAP.count(pat)) HASHMAP[pat] = ++cntPattern;
    return HASHMAP[pat];
}

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>